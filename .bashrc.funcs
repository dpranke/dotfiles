# ap - append `dir` to the var if it's not already there and it exists.
#      `var` defaults to PATH if not given.
#      `-n` requires `dir` to be nonempty
#      `-v` be verbose about what happens
#      If `after` is given, the dir is inserted after `after` in the `var`
#      instead of at the end of var.
function ap() {
  local OPTARG OPTIND after= dir= nonempty=0 var=PATH verbose=0

  ap_usage() {
    echo "usage: ap [-nv] [-p var] [ after ] dir"
    echo ""
    echo "  -n only add if the directory is not empty"
    echo "  -v be verbose about what we do"
  }

  vecho() {
    if [[ $verbose -eq 1 ]] ; then
      echo "$@"
    fi
  }

  while getopts "hnp:v" opt
  do
    case ${opt} in
      n) nonempty=1 ;;
      p) var=${OPTARG} ;;
      v) verbose=1 ;;
      h | ?)
        ap_usage
        return
        ;;
    esac
  done

  shift $(( $OPTIND - 1))
  if [[ $# -eq 2 ]]; then
    after=$1
    dir=$2
  elif [[ $# -eq 1 ]]; then
    dir=$1
  else
    ap_usage
    return
  fi

  if [[ ("${!var}" =~ ":${dir}:") || ("${!var}" =~ ^"${dir}:") || \
    ("${!var}" =~ ":${dir}"$) ]]
  then
    vecho "${dir} is already in the ${var}"
    return
  fi

  if [[ ! -d "${dir}" ]]; then
    vecho "${dir} doesn't exist"
    return
  fi

  if [[ ${nonempty} -eq 1 ]]; then
    local dotglob=0
    if [[ "$(shopt dotglob)" =~ on ]]; then
      dotglob=1
    fi
    shopt -s dotglob
    if [[ $(echo -n "$dir/*") = "$dir/*" ]]; then
      vecho "${dir} is empty, not adding to ${var}"
      if [[ $dotglob = 0 ]]; then
        shopt -u dotglob
      fi
      return
    else
      if [[ $dotglob = 0 ]]; then
        shopt -u dotglob
      fi
    fi
  fi

  if [[ "${after}" == "" ]]; then
    export ${var}="${!var}:${dir}"
    vecho "${dir} appended to ${var}"
    return
  fi

  if [[ "${!var}" =~ "${after}" ]]; then
    export ${var}="${!var/${after}/"${after}:${dir}"}"
    vecho "${dir} added to ${var} after ${after}"
  else
    vecho "${after} isn't in the ${var}"
  fi
}

function and() {
  autoninja -C $csrc/out/dbg "$@"
}

function andc() {
  and chrome "$@"
}

function anr() {
  autoninja -C $csrc/out/rel "$@"
}

function anrc() {
  anr chrome "$@"
}

function anr2() {
  autoninja -C $csrc/out/rel2 "$@"
}

function anr2c() {
  anr2 chrome "$@"
}

function df() {
  command df -h "$@"
}

function dt() {
    cd $dt/"$@"
}

function du() {
  command du -h "$@"
}

function dve() {
  # deactivate current python venv; see also ve().
  deactivate
}

# csrc - cd to $csrc/$*
function csrc() {
  if [ ! -z "$csrc" ]
  then
    cd ${csrc}/"$@"
  else
    echo "not in a view"
  fi
}

function gb() {
  git map-branches "$@"
}

function gdu() {
  git diff @{u} "$@"
}

function gdun() {
  git diff @{u} --name-only "$@"
}

function geu() {
  ge $(git diff --name-only @{u} "$@")
}

function gng() {
  git grep "$@" -- \*.gn \*.gni
}

function gps() {
  git pull && gclient sync -D
}

function h() {
  history "$@"
}

function home() {
  cd "$HOME/$@"
}

# ip - insert directory `dir` at the front of the `var` env variable if it's
#      not already there and `dir` exists.
#      `var` defaults to PATH if not given
#      `-n` requires `dir` to be nonempty
#      `-v` be verbose about what happens
#      If `before` is given, the dir is inserted before `before` instead
#      of at the front of var.
function ip() {
  local OPTARG OPTIND before= dir= nonempty=0 usage var=PATH vecho verbose=0

  usage() {
    echo "usage: ip [-nv] [-p var] dir [ before ]"
    echo ""
    echo "  -n only add if the directory is not empty"
    echo "  -v be verbose about what we do"
  }

  vecho() {
    if [[ $verbose -eq 1 ]] ; then
      echo "$@"
    fi
  }

  while getopts "hnp:v" opt
  do
    case ${opt} in
      n) nonempty=1 ;;
      p) var=${OPTARG} ;;
      v) verbose=1 ;;
      h | ?)
        usage
        return
        ;;
    esac
  done

  shift $(( $OPTIND - 1))
  if [[ $# -eq 2 ]]; then
    dir=$1
    before=$2
  elif [[ $# -eq 1 ]]; then
    dir=$1
  else
    usage
    return
  fi

  if [[ ("${!var}" =~ ":${dir}:") || ("${!var}" =~ ^"${dir}:") || \
    ("${!var}" =~ ":${dir}"$) ]]
  then
    vecho "${dir} is already in the ${var}"
    return
  fi

  if [[ ! -d "${dir}" ]]; then
    vecho "${dir} doesn't exist"
    return
  fi

  if [[ ${nonempty} -eq 1 ]]; then
    local dotglob=0
    if [[ "$(shopt dotglob)" =~ on ]]; then
      dotglob=1
    fi
    shopt -s dotglob
    if [[ $(echo -n "$dir/*") = "$dir/*" ]]; then
      vecho "${dir} is empty, not adding to ${var}"
      if [[ $dotglob = 0 ]]; then
        shopt -u dotglob
      fi
      return
    else
      if [[ $dotglob = 0 ]]; then
        shopt -u dotglob
      fi
    fi
  fi

  if [[ "${before}" == "" ]]; then
    export ${var}="${dir}:${!var}"
    vecho "${dir} prepended to ${var}"
    return
  fi

  if [[ "${!var}" =~ "${before}" ]]; then
    export ${var}="${!var/${before}/"${dir}:${before}"}"
    vecho "${dir} added to ${var} before ${before}"
  else
    vecho "${before} isn't in the ${var}"
  fi

  return
}

alias ls='ls -F'

function pset() {
  set | pset_aux "$@"
}

# redot - re-read dot files
function redot() {
  local old_view
  old_view=$view
  . ~/.bashrc
  if [ -n "$old_view" ]
  then
    sv $old_view
    cd -
  fi
}

function repeat() {
  count=$1
  shift

  while [ $count -ne 0 ]
  do
    "$@"
    if [ $? -gt 128 ]
    then
      return
    fi
    count=$((count - 1))
  done
}

# rp - remove path component
#   usage: rp [var] component
function rp() {
  # set -x
  local comp var
  if [ $# -eq 2 ]
  then
    var=$1
    shift
  else
    var=PATH
  fi
  comp=$1
  if [[ "${!var}" =~ ^"$1:" ]]
  then
    # front
    export ${var}=${!var/#$comp:/}
  elif [[ "${!var}" =~ ":$1:" ]]
  then
    # middle
    export ${var}=${PATH/:$comp:/:}
  elif [[ "${!var}" =~ ":$1"$ ]]
  then
    # end
    export ${var}=${!var/%:$comp/}
  else
    # not found
    :
  fi
  # set +x
}


function setprompt() {
  if [ "$TERM" = "xterm" -o "$TERM" = "xterm-color" -o \
       "$TERM" = "xterm-256color" -o "$TERM" = "msys" -o "$TERM" = "cygwin" ]
  then
    if [ ! -z "$view" ]
    then
      if [ "$GIT_PRESENT" = "1" -a "$OSNAME" != "cygwin" ]
      then
        PS1='\[\e]0;\u@\h ($view|$(gitbranch)):\w\a\]\W $ '
      else
        PS1='\[\e]0;\u@\h ($view):\w\a\]\W $ '
      fi
    else
      PS1='\[\e]0;\u@\h:\w\a\]\W $ '
    fi
  else
    if [ ! -z "$view" ]
    then
      PS1="($view) \W $ "
    else
      PS1="\W $ "
    fi
  fi
}

# Turn on shell tracing if necessary, execute a command, then turn off tracing
# if we turned it on before. If tracing is already on, just execute the command.
function shdbg() {
  local x=0
  if [[ !("$-" =~ "x") ]]; then
    x=1
    set -x
  fi

  "$@"

  if [[ $x = 1 ]]; then
    set +x
  fi
}

function src() {
  cd "$src/$@"
}

function sv() {
  if [ "$1" = "-d" ]
  then
    unset view csrc
    setprompt
    return
  fi

  local new_view=$1

  if [ ! -d "$src/$new_view" ]
  then
    echo "no such view '$new_view' under $src"
    return
  fi

  export view=$new_view
  export csrc=$(gcsrc $src/$new_view)
  setprompt
  cd $csrc
}

function uhome() {
  cd "$HOME/$@"
}

function ve() {
  if [[ "${1}" == "" ]]; then
    if [[ -e ./.venv/pyvenv.cfg ]]; then
      source ".venv/bin/activate"
    elif [[ -d "${csrc}/.venv/pyvenv.cfg" ]]; then
      source "${csrc}/.venv/bin/activate"
    else
      echo "No venv found in current directory"
    fi
  elif [[ -e "${1}/pyvenv.cfg" ]]; then
    source "${1}/bin/activate"
  else
    echo "No venv found in ${1}"
  fi
}

# echo current window size
function ws() {
    echo "${COLUMNS}x${LINES}"
}

# Bash completion for sv()
# return any directories matching $src/c\.*
function _sv_comp() {
  local cur prev opts
  COMPREPLY=()
  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  opts=$(cd $src ; \ls -1 | grep '^c\.' | sed 's/c\.//g' | tr "\n" " ")

  COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
  return 0
}

complete -F _sv_comp sv
