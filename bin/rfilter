#!/usr/bin/env python

from __future__ import with_statement

import optparse
import pdb
import re
import string
import sys


def _rule(name, pattern=None, replacement=None):
    return (name, pattern, replacement)

def skip(pattern):
    return _rule('skip', pattern, None)

def action(pattern, replacement):
    return _rule('action', pattern, replacement)
   
def target(pattern, replacement):
    return _rule('target', pattern, replacement)

def echo():
    return _rule('echo')

def step(pattern, replacement):
    return _rule('step', pattern, replacement)

def result(pattern, replacement):
    return _rule('result', pattern, replacement)


def _compile_fn(obj, name, pattern, replacement):
    if pattern:
        regexp = re.compile(pattern)
    def _echo(obj, line):
        obj.write_rule(name, line)
        return True

    def _match(obj, line):
        if regexp.match(line):
            obj.write_rule(name, line)
            return True
        return False

    def _replace(obj, line):
        if regexp.match(line):
            obj.write_rule(name, regexp.sub(replacement, line))
            return True
        return False

    if pattern is None:
        return _echo
    if replacement is None:
        return _match
    return _replace

 
class Filter(object):
    RECORD_DEFAULT = ['target', 'action', 'step', 'echo']

    def __init__(self, options, rules, templates):
        self._inp = None
        self._outp = None
        self._options = options
        self._rules = rules
        self._compiled_rules = self.compile(rules)
        self._templates = templates
        self._compiled_templates = {}
        for (key, value) in templates.iteritems():
            self._compiled_templates[key] = string.Template(value)
        self._null_template = string.Template('')

    def compile(self, rules):
        compiled_rules = []
        for r in rules:
            (name, pattern, replacement) = r
            compiled_rules.append(_compile_fn(self, name, pattern, replacement))
        return compiled_rules
            
    def loop(self, inp, outp):
        self._inp = inp
        self._outp = outp
        for line in self._inp:
            for fn in self._compiled_rules:
                if fn(self, line.rstrip()):
                    break

    def template(self, name):
        if name in self._options.record:
            return self._compiled_templates[name]
        return self._null_template

    def write(self, s):
        self._outp.write(s)

    def write_rule(self, rule_name, s):
        t = self.template(rule_name)
        if self._options.trace:
            print >>sys.stderr, "@%s('%s')" % (rule_name, s)
        self.write_template(t, s)

    def write_template(self, template, s):
        self.write(template.safe_substitute(s=s))


class XCodeBuildFilter(Filter):
    TEMPLATES = {
        'action': '    $s\n',
        'step':   '  $s\n',
        'target': 'target($s)\n',
        'echo':   '      >> $s\n',
        'skip':   '',
    }

    RULES = [
        skip(r'^\s*(setenv|cd|ARCHS|OBJROOT|SYMROOT|/usr/bin/make|/usr/bin/touch|/bin/sh)'),
        skip(r'^Build settings from command line'),
        skip(r'^$'),
        skip(r'^make: Nothing to be done for '),
        skip(r'^Check dependencies'),
        skip(r'^\s+/Developer.*pbxcp'),
        skip(r'^\s+/Developer/usr/bin/(gcc|g\+\+)'),
        skip(r'^Making app bundle'),
        action(r'^CpHeader [^\s]+ ([^\s]+)',
               r'cp \1'),
        action(r'^CompileC.+/([^\s]+).*',
               r'cc \1'),
        action(r'^Ld.+/([^\s]+).*',
               r'ld \1'),
        action(r'^Touch .*/(.*)$',
               r'touch \1'),
        action(r'^Clean.Remove.+/(\w+)',
               r'rm -fr \1'),
        action(r'^ProcessPCH\+\+\s+[^\s]+\s+([^\s]+).*',
               r'pch \1'),
        action(r'^ProcessInfoPlistFile\s+[^\s]+\s+([^\s]+).*',
               r'plist \1'),
        action(r'^mkdir -p.+/(\w+)',
               r'mkdir \1'),
        action(r'^/usr/bin/swig -o .*/([^\s]+).*',
               r'swig \1'),
        action(r'^gcc -g -dynamiclib -o [^\s]+/([^\s]+)\s.*',
               r'gcc -g -dynamiclib -o \1'),
        skip(r'^\s*/bin/rm'),
        skip(r'^\s*rm -f'),
        skip(r'^ProcessPCH\s.*'),
        skip(r'^\s*builtin-infoPlistUtility'),
        target(r'=== (CLEAN|BUILD) (NATIVE|LEGACY|AGGREGATE) TARGET (.+) OF PROJECT (.+) WITH.*',
               r'\4/\3'),
        step(r'PhaseScriptExecution "([^"]*)".*',
             r'\1'),
        skip(r'^.*\.sh$'),
        skip(r'^ExternalBuildToolExecution'),
        result(r'\*\* (CLEAN|BUILD) (SUCCEEDED|FAILED) \*\*',
               r'\1 \2'),
        echo(),
        ]

    def __init__(self, options):
        Filter.__init__(self, options, rules=XCodeBuildFilter.RULES,
                        templates=XCodeBuildFilter.TEMPLATES)


def main(argv=None):
    parser = optparse.OptionParser()
    parser.add_option('-s', '--ruleset', action='store',
                      default='xcode',
                      help='filter ruleset to use (default=xcode)')
    parser.add_option('-r', '--record', action='store',
                      default=','.join(Filter.RECORD_DEFAULT),
                      help="comma-separated list of rules to display "
                           "(default: '%s'" % ','.join(Filter.RECORD_DEFAULT))
    parser.add_option('--trace', action='store_true',
                      default=False,
                      help="trace rules as they fire")
    options, args = parser.parse_args(argv)
    if options.ruleset == 'xcode':
        filter = XCodeBuildFilter(options)
    else:
        sys.exit(-1)

    if args:
        for arg in args:
            with file(arg) as f:
                filter.loop(f, sys.stdout)
    else:
        filter.loop(sys.stdin, sys.stdout)
                      
if __name__ == '__main__':
    main()
